use std::vec;

use crate::{
    abi::program::{ErrorDetails, ErrorPosition, PanickingCall, ProgramABI},
    error_codes::ErrorSignal,
};

/// Information about a revert that occurred during a transaction execution.
#[derive(Debug, PartialEq, Eq)]
pub struct RevertInfo {
    pub revert_code: u64,
    pub kind: RevertKind,
}

#[derive(Debug, PartialEq, Eq)]
pub enum RevertKind {
    /// This is the most general kind of a revert, where we only know the revert code.
    /// E.g., reverts caused by `__revert` calls.
    RawRevert,
    /// Reverts caused by known functions, like, e.g., `assert` or `require`, that provide known error signals.
    /// For such reverts, we can provide the error message.
    KnownErrorSignal { err_msg: String },
    /// Reverts caused by a `panic` expression.
    Panic {
        err_msg: Option<String>,
        err_val: Option<String>,
        pos: ErrorPosition,
        backtrace: Vec<PanickingCall>,
    },
}

impl RevertInfo {
    pub fn raw_revert(revert_code: u64) -> Self {
        Self {
            revert_code,
            kind: RevertKind::RawRevert,
        }
    }

    /// `decode_last_log_data` is a function that accepts a log ID and a program ABI,
    /// and returns the string representation of the decoded
    /// error value of the last log receipt, if that is a log data receipt.
    pub fn new(
        revert_code: u64,
        program_abi: Option<&ProgramABI>,
        decode_last_log_data: impl Fn(&str, &ProgramABI) -> Option<String>,
    ) -> Self {
        if let Ok(error_signal) = ErrorSignal::try_from_revert_code(revert_code) {
            Self {
                revert_code,
                kind: RevertKind::KnownErrorSignal {
                    err_msg: error_signal.to_string(),
                },
            }
        } else if let Some(program_abi) = program_abi {
            // We have the program ABI available, and can try to extract more information about the revert.
            let (error_code, panicking_calls) = if program_abi.spec_version.is_v1_1() {
                // In v1.1, the revert code is the error code and we don't have panicking calls.
                (revert_code, vec![])
            } else if program_abi.spec_version.is_v1_2() {
                // In v1.2, the revert code encodes the error code and panicking calls
                // using the following format:
                // `1_pppppppp_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC`
                // where `pppppppp` is the error code, and `CCCCCCCCCCC` are the type IDs
                // of the panicking calls.
                #[allow(clippy::unusual_byte_groupings)]
                const IS_REVERT_CAUSED_BY_PANIC_MASK: u64 =
                    0b1_00000000_00000000000_00000000000_00000000000_00000000000_00000000000;
                #[allow(clippy::unusual_byte_groupings)]
                const ERROR_CODE_MASK: u64 =
                    0b0_11111111_00000000000_00000000000_00000000000_00000000000_00000000000;
                #[allow(clippy::unusual_byte_groupings)]
                const SINGLE_PANICKING_CALL_MASK: u64 =
                    0b0_00000000_00000000000_00000000000_00000000000_00000000000_11111111111;

                if revert_code & IS_REVERT_CAUSED_BY_PANIC_MASK == 0 {
                    // The revert is not caused by a panic.
                    (0, vec![])
                } else {
                    // The revert is caused by a panic.
                    let error_code = (revert_code & ERROR_CODE_MASK) >> 55;

                    let panicking_calls = (0..=4)
                        .map(|i| (revert_code >> (i * 11)) & SINGLE_PANICKING_CALL_MASK)
                        .filter(|&panicking_call| panicking_call != 0)
                        .collect();
                    (error_code, panicking_calls)
                }
            } else {
                // Unknown ABI version. This should never happen with the ABIs generated by the Sway compiler.
                (0, vec![])
            };

            if let Some(error_details) = program_abi
                .error_codes
                .as_ref()
                .and_then(|error_codes| error_codes.get(&error_code))
            {
                // The revert code is caused by a panic.
                let (pos, err_msg, err_val) =
                    extract_panic_pos_msg_val(error_details, program_abi, decode_last_log_data);

                let backtrace = panicking_calls
                    .into_iter()
                    .filter_map(|panicking_call| {
                        program_abi
                            .panicking_calls
                            .as_ref()
                            .and_then(|panicking_calls| panicking_calls.get(&panicking_call))
                            .cloned()
                    })
                    .collect();

                Self {
                    revert_code,
                    kind: RevertKind::Panic {
                        err_msg,
                        err_val,
                        pos,
                        backtrace,
                    },
                }
            } else {
                // The revert code is not caused by a panic.
                Self::raw_revert(revert_code)
            }
        } else {
            // No known error signal, and no ABI available. We can't extract any additional information.
            Self::raw_revert(revert_code)
        }
    }
}

/// Extracts `panic`'s position, error message, and error value from the provided `error_details`.
fn extract_panic_pos_msg_val(
    error_details: &ErrorDetails,
    program_abi: &ProgramABI,
    decode_last_log_data: impl Fn(&str, &ProgramABI) -> Option<String>,
) -> (ErrorPosition, Option<String>, Option<String>) {
    /// Types that implement the `std::marker::Error` trait, and whose instances
    /// can be used as arguments to the `panic` expression.
    enum ErrorType {
        Unknown,
        Unit,
        Str,
        Enum,
    }

    impl ErrorType {
        fn from_type_name(type_name: &str) -> Self {
            match type_name {
                "()" => ErrorType::Unit,
                "str" => ErrorType::Str,
                name if name.starts_with("enum ") => ErrorType::Enum,
                _ => ErrorType::Unknown,
            }
        }
    }

    // 1. Extract the position.
    let pos = error_details.pos.clone();

    // 2. Extract the error message and error value.
    // Message and log ID are mutually exclusive.
    let (err_msg, err_val) = if let Some(msg) = &error_details.msg {
        (Some(msg.clone()), None)
    } else if let Some(log_id) = &error_details.log_id {
        // Because we got the error code, we know that the revert is a result of `panic`king.
        // The log receipt created by the `panic` expression will be the last one in the logs.
        let err_val = decode_last_log_data(log_id, program_abi);

        match program_abi
            .logged_types
            .iter()
            .flatten()
            .find(|logged_type| logged_type.log_id == *log_id)
            .and_then(|logged_type| {
                program_abi.concrete_types.iter().find(|concrete_type| {
                    concrete_type.concrete_type_id == logged_type.concrete_type_id
                })
            })
            .map(|type_decl| &type_decl.type_field)
        {
            // All of the `(None, err_val)` cases below can happen only if the ABI is malformed.
            // We handle that case gracefully by returning `None` for the error message,
            // but still returning the error value if it is provided.
            // Note that not having an error value is also possible only if the ABI is malformed.
            Some(error_type_name) => match ErrorType::from_type_name(error_type_name) {
                ErrorType::Unit => (None, err_val),
                ErrorType::Str => {
                    // This is the case where the error value is a non-const evaluated string slice.
                    // The error message will be null in the JSON ABI and the log value will be the string slice
                    // decoded like: `AsciiString { data: "<the actual error message>" }`.
                    // In this case, we will actually show `<the actual error message>` as the error message
                    // and set the error value to `None`.
                    // The `AsciiString { data: "<the actual error message>" }` will still be displayed in the logs,
                    // We "parse" the error message out, by gracefully extracting it from the decoded logged value.
                    if let Some(err_val) = err_val {
                        let left_quote_index = err_val.find('"').unwrap_or_default();
                        let right_quote_index = err_val.rfind('"').unwrap_or_default();
                        if left_quote_index < right_quote_index {
                            let err_msg =
                                err_val[left_quote_index..right_quote_index].trim_matches('"');
                            (Some(err_msg.to_string()), None)
                        } else {
                            (None, Some(err_val)) // Malformed error value, handle gracefully.
                        }
                    } else {
                        (None, err_val) // Malformed ABI, handle gracefully.
                    }
                }
                ErrorType::Enum => {
                    if let Some(err_val) = err_val {
                        let err_msg = program_abi
                            .metadata_types
                            .iter()
                            .find(|metadata_type| metadata_type.type_field == *error_type_name)
                            .and_then(|metadata_type| {
                                metadata_type.components.as_ref().and_then(|components| {
                                    // The component name will be the name of the error enum variant.
                                    // We extract the concrete error enum variant name from the logged error value.
                                    // The logged error value will either be a `SomeErrorVariant` or `SomeErrorVariant(value)`.
                                    // So, the name will be the first part of the string, up to the first `(` if it exists.
                                    // TODO: Is there a better way to match the logged error value to the component name?
                                    err_val.split('(').next().map(|variant_name| {
                                        components
                                            .iter()
                                            .find(|component| {
                                                component.name.as_str() == variant_name
                                            })
                                            .and_then(|component| component.error_message.clone())
                                    })
                                })
                            })
                            .flatten();

                        (err_msg, Some(err_val))
                    } else {
                        (None, err_val) // Malformed ABI, handle gracefully.
                    }
                }
                ErrorType::Unknown => (None, err_val), // Malformed ABI, handle gracefully.
            },
            None => (None, err_val), // Malformed ABI, handle gracefully.
        }
    } else {
        // We got neither a message nor a log ID.
        // This means malformed ABI, handle gracefully.
        (None, None)
    };
    (pos, err_msg, err_val)
}

#[cfg(test)]
mod tests {
    use rstest::rstest;

    use super::*;
    use crate::abi::program::{
        ConcreteTypeId, ErrorDetails, ErrorPosition, LoggedType, MetadataTypeId, PanickingCall,
        ProgramABI, TypeConcreteDeclaration,
    };
    use crate::error_codes::*;
    use core::panic;
    use std::collections::BTreeMap;

    #[test]
    fn raw_revert() {
        let revert_code = 0x12345678;

        let revert_info = RevertInfo::raw_revert(revert_code);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::RawRevert,
        };

        assert_eq!(revert_info, expected);
    }

    #[test]
    fn new_known_error_signal() {
        let known_error_signals = [
            (FAILED_REQUIRE_SIGNAL, "std::revert::require"),
            (
                FAILED_TRANSFER_TO_ADDRESS_SIGNAL,
                "std::token::transfer_to_address",
            ),
            (FAILED_SEND_MESSAGE_SIGNAL, "std::message::send_message"),
            (FAILED_ASSERT_EQ_SIGNAL, "std::assert::assert_eq"),
            (FAILED_ASSERT_SIGNAL, "std::assert::assert"),
            (FAILED_ASSERT_NE_SIGNAL, "std::assert::assert_ne"),
            (REVERT_WITH_LOG_SIGNAL, "std::revert::revert_with_log"),
        ];

        for (revert_code, function) in known_error_signals {
            let revert_info = RevertInfo::new(revert_code, None, |_, _| None);

            let expected = RevertInfo {
                revert_code,
                kind: RevertKind::KnownErrorSignal {
                    err_msg: format!("Failing call to `{function}`."),
                },
            };

            assert_eq!(revert_info, expected);
        }
    }

    #[test]
    fn new_without_abi() {
        let revert_code = 0x12345678;
        let revert_info = RevertInfo::new(revert_code, None, |_, _| None);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::RawRevert,
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_no_error_codes(#[values("1.1", "1.2")] version: &str) {
        let revert_code = 0x12345678;

        let revert_info = RevertInfo::new(
            revert_code,
            Some(&ProgramABIBuilder::new(version).build()),
            |_, _| None,
        );

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::RawRevert,
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_unknown_error_code(#[values("1.1", "1.2")] version: &str) {
        let (error_code, unknown_revert_code) = if version == "1.1" {
            (0xffff_ffff_0000_0000_u64, 0xffff_ffff_0000_aaaa)
        } else if version == "1.2" {
            (43, v1_2_revert_code(111, &[]))
        } else {
            panic!("Unknown version: {version}");
        };

        let error_details = create_panic_error_details("test", None);

        // Create ABI with the known error code.
        let abi = ProgramABIBuilder::new(version)
            .insert_error_code(error_code, error_details.clone())
            .build();

        // Create `RevertInfo` with the revert code of the unknown error code.
        let revert_info = RevertInfo::new(unknown_revert_code, Some(&abi), |_, _| None);

        let expected = RevertInfo {
            revert_code: unknown_revert_code,
            kind: RevertKind::RawRevert,
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_error_code_with_msg(#[values("1.1", "1.2")] version: &str) {
        let (error_code, revert_code) = if version == "1.1" {
            (0xffff_ffff_0000_0000_u64, 0xffff_ffff_0000_0000)
        } else if version == "1.2" {
            (43, v1_2_revert_code(43, &[]))
        } else {
            panic!("Unknown version: {version}");
        };

        let error_details = create_panic_error_details("test", None);

        let abi = ProgramABIBuilder::new(version)
            .insert_error_code(error_code, error_details.clone())
            .build();

        let revert_info = RevertInfo::new(revert_code, Some(&abi), |_, _| None);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::Panic {
                err_msg: error_details.msg,
                err_val: None,
                pos: error_details.pos,
                backtrace: vec![],
            },
        };

        assert_eq!(revert_info, expected);
    }

    #[test]
    fn new_with_unknown_abi_version_error_code_with_msg() {
        let (error_code, revert_code) = (0xffff_ffff_0000_0000_u64, 0xffff_ffff_0000_0000);

        let error_details = create_panic_error_details("test", None);

        let abi = ProgramABIBuilder::new("<unknown>")
            .insert_error_code(error_code, error_details.clone())
            .build();

        let revert_info = RevertInfo::new(revert_code, Some(&abi), |_, _| None);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::RawRevert,
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_error_code_with_log_id(#[values("1.1", "1.2")] version: &str) {
        let (error_code, revert_code) = if version == "1.1" {
            (0xffff_ffff_0000_0000_u64, 0xffff_ffff_0000_0000)
        } else if version == "1.2" {
            (43, v1_2_revert_code(43, &[]))
        } else {
            panic!("Unknown version: {version}");
        };

        const LOG_ID: &str = "<log_id>";
        const DECODED_ERROR_VALUE: &str = "<decoded_error_value>";

        let error_details = create_panic_error_details("test", Some(LOG_ID.to_string()));

        let abi = ProgramABIBuilder::new(version)
            .insert_error_code(error_code, error_details.clone())
            .build();

        let decode_last_log_data = |log_id: &str, _abi: &ProgramABI| -> Option<String> {
            (log_id == LOG_ID).then(|| DECODED_ERROR_VALUE.to_string())
        };

        let revert_info = RevertInfo::new(revert_code, Some(&abi), decode_last_log_data);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::Panic {
                err_msg: None, // This test doesn't mock the ProgramABI to have an error enum with a message.
                err_val: Some(DECODED_ERROR_VALUE.to_string()),
                pos: error_details.pos,
                backtrace: vec![],
            },
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_error_code_with_logged_str_type(#[values("1.1", "1.2")] version: &str) {
        let (error_code, revert_code) = if version == "1.1" {
            (0xffff_ffff_0000_0000_u64, 0xffff_ffff_0000_0000)
        } else if version == "1.2" {
            (43, v1_2_revert_code(43, &[]))
        } else {
            panic!("Unknown version: {version}");
        };

        const LOG_ID: &str = "<log_id>";
        const STR_ERROR_MESSAGE: &str = "`str` error message.";

        let error_details = create_panic_error_details("test", Some(LOG_ID.to_string()));

        let abi = ProgramABIBuilder::new(version)
            .insert_error_code(error_code, error_details.clone())
            .insert_str_logged_type(LOG_ID)
            .build();

        let decode_last_log_data = |log_id: &str, _abi: &ProgramABI| -> Option<String> {
            (log_id == LOG_ID).then(|| format!("AsciiString {{ data: \"{STR_ERROR_MESSAGE}\" }}"))
        };

        let revert_info = RevertInfo::new(revert_code, Some(&abi), decode_last_log_data);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::Panic {
                err_msg: Some(STR_ERROR_MESSAGE.to_string()),
                err_val: None,
                pos: error_details.pos,
                backtrace: vec![],
            },
        };

        assert_eq!(revert_info, expected);
    }

    #[rstest]
    fn new_with_abi_v1_2_with_backtrace(#[values(0, 1, 2, 3, 4, 5)] num_of_panicking_calls: usize) {
        let error_code = 42;
        let error_details = create_panic_error_details("test", None);

        let mut abi_builder =
            ProgramABIBuilder::new("1.2").insert_error_code(error_code, error_details.clone());

        let panicking_calls_and_ids: Vec<(PanickingCall, u64)> = (1..=num_of_panicking_calls)
            .map(|i| {
                let call = create_panicking_call(i);
                // Create some quasi-random ID for the panicking call.
                let id = (i * 17 + 1) as u64;
                (call, id)
            })
            .collect();

        for (panicking_call, panicking_call_id) in panicking_calls_and_ids.iter() {
            abi_builder =
                abi_builder.insert_panicking_call(*panicking_call_id, panicking_call.clone());
        }

        let revert_code = v1_2_revert_code(
            error_code,
            &panicking_calls_and_ids
                .iter()
                .map(|(_, id)| *id)
                .collect::<Vec<_>>(),
        );

        let revert_info = RevertInfo::new(revert_code, Some(&abi_builder.build()), |_, _| None);

        let expected = RevertInfo {
            revert_code,
            kind: RevertKind::Panic {
                err_msg: error_details.msg,
                err_val: None,
                pos: error_details.pos,
                backtrace: panicking_calls_and_ids
                    .into_iter()
                    .map(|(call, _)| call)
                    .rev()
                    .collect(),
            },
        };

        assert_eq!(revert_info, expected);
    }

    struct ProgramABIBuilder {
        abi: ProgramABI,
    }

    impl ProgramABIBuilder {
        fn new(version: &str) -> Self {
            Self {
                abi: ProgramABI {
                    program_type: "script".to_string(),
                    spec_version: version.into(),
                    encoding_version: "1".into(),
                    ..Default::default()
                },
            }
        }

        fn insert_error_code(mut self, code: u64, details: ErrorDetails) -> Self {
            if self.abi.error_codes.is_none() {
                self.abi.error_codes = Some(BTreeMap::new());
            }

            self.abi.error_codes.as_mut().unwrap().insert(code, details);

            self
        }

        fn insert_panicking_call(mut self, call_id: u64, call: PanickingCall) -> Self {
            assert!(call_id > 0, "`call_id` must be greater than 0");
            assert!(call_id < 0b11111111111, "`call_id` must be less than 2^11");

            if self.abi.panicking_calls.is_none() {
                self.abi.panicking_calls = Some(BTreeMap::new());
            }

            self.abi
                .panicking_calls
                .as_mut()
                .unwrap()
                .insert(call_id, call);

            self
        }

        fn insert_str_logged_type(mut self, log_id: &str) -> Self {
            if self.abi.logged_types.is_none() {
                self.abi.logged_types = Some(vec![]);
            }

            let logged_type = LoggedType {
                log_id: log_id.to_string(),
                concrete_type_id: ConcreteTypeId("<str_type_id>".to_string()),
            };

            self.abi.logged_types.as_mut().unwrap().push(logged_type);

            let concrete_type = TypeConcreteDeclaration {
                type_field: "str".to_string(),
                concrete_type_id: ConcreteTypeId("<str_type_id>".to_string()),
                metadata_type_id: Some(MetadataTypeId(0)),
                type_arguments: None,
                alias_of: None,
            };

            self.abi.concrete_types.push(concrete_type);

            self
        }

        fn build(self) -> ProgramABI {
            self.abi
        }
    }

    fn v1_2_revert_code(error_code: u64, panicking_calls: &[u64]) -> u64 {
        assert!(
            error_code <= 0b11111111,
            "`error_code` must be less than or equal to 2^8"
        );
        assert!(
            panicking_calls.len() <= 5,
            "`panicking_calls` must have at most 5 elements"
        );
        for &panicking_call_id in panicking_calls {
            assert!(
                panicking_call_id < 0b11111111111,
                "`panicking_call_id` must be less than 2^11"
            );
        }

        #[allow(clippy::unusual_byte_groupings)]
        let mut revert_code =
            0b1_00000000_00000000000_00000000000_00000000000_00000000000_00000000000; // Set panic bit.
        revert_code |= error_code << 55; // Set error code.

        let num_of_panicking_calls = panicking_calls.len();
        for (i, call) in panicking_calls.iter().enumerate() {
            let shift = num_of_panicking_calls - 1 - i;
            revert_code |= call << (shift * 11);
        }

        revert_code
    }

    fn create_panic_error_details(fn_name: &str, log_id: Option<String>) -> ErrorDetails {
        ErrorDetails {
            pos: ErrorPosition {
                function: format!("test::module_{fn_name}::{fn_name}"),
                pkg: "test@0.1.0".to_string(),
                file: format!("src/module_{fn_name}.sw"),
                line: 10,
                column: 5,
            },
            msg: log_id
                .is_none()
                .then(|| format!("Error in function `{fn_name}`.")),
            log_id,
        }
    }

    fn create_panicking_call(call_index: usize) -> PanickingCall {
        assert!(call_index > 0, "`call_index` must be greater than 0");
        assert!(
            call_index <= 5,
            "`call_index` must be less than or equal to 5"
        );
        PanickingCall {
            pos: ErrorPosition {
                function: format!("test::caller_module_{call_index}::caller_function_{call_index}"),
                pkg: "test@0.1.0".to_string(),
                file: format!("src/caller_module_{call_index}.sw"),
                line: 20,
                column: 15,
            },
            function: format!("test::panicking_function_{call_index}"),
        }
    }
}
