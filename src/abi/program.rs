//! Defines a set of serializable types required for the Fuel VM ABI.

use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};

/// FuelVM ABI representation in JSON, originally specified
/// [here](https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md).
///
/// This type may be used by compilers and related tooling to convert an ABI
/// representation into native Rust structs and vice-versa.
#[derive(Default, Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProgramABI {
    pub program_type: String,
    pub spec_version: Version,
    pub encoding_version: Version,
    pub concrete_types: Vec<TypeConcreteDeclaration>,
    pub metadata_types: Vec<TypeMetadataDeclaration>,
    pub functions: Vec<ABIFunction>,
    pub logged_types: Option<Vec<LoggedType>>,
    pub messages_types: Option<Vec<MessageType>>,
    pub configurables: Option<Vec<Configurable>>,
    pub error_codes: Option<BTreeMap<u64, ErrorDetails>>,
    pub panicking_calls: Option<BTreeMap<u64, PanickingCall>>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Version(pub String);

impl From<&str> for Version {
    fn from(value: &str) -> Self {
        Version(value.into())
    }
}

impl Version {
    pub fn major(&self) -> Option<&str> {
        let s = self.0.split('.').next().map(|x| x.trim());
        match s {
            Some("") => None,
            s => s,
        }
    }

    pub fn minor(&self) -> Option<&str> {
        let s = self.0.split('.').nth(1).map(|x| x.trim());
        match s {
            Some("") => None,
            s => s,
        }
    }

    /// Returns `true` if the ABI version is `1.1`.
    ///
    /// The v1.1 introduced the "errorCodes" field:
    ///  - each "errorCodes" entry key is equal to a revert code generated by a `panic` expression.
    pub fn is_v1_1(&self) -> bool {
        self.0 == "1.1"
    }

    /// Returns `true` if the ABI version is `1.2`.
    ///
    /// The v1.2 introduced the "panickingCalls" field and changed the semantics of
    /// the key in the "errorCodes" field:
    ///  - the key in the "errorCodes" field is the `u64` value of the `pppppppp` part of the `1_pppppppp_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC_CCCCCCCCCCC` encoded revert code generated by a `panic` expression.
    pub fn is_v1_2(&self) -> bool {
        self.0 == "1.2"
    }
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub struct ConcreteTypeId(pub String);

impl From<&str> for ConcreteTypeId {
    fn from(value: &str) -> Self {
        ConcreteTypeId(value.into())
    }
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub struct MetadataTypeId(pub usize);

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
#[serde(untagged)]
pub enum TypeId {
    Concrete(ConcreteTypeId),
    Metadata(MetadataTypeId),
}

impl Default for TypeId {
    fn default() -> Self {
        TypeId::Metadata(MetadataTypeId(usize::MAX))
    }
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ABIFunction {
    pub name: String,
    pub inputs: Vec<TypeConcreteParameter>,
    pub output: ConcreteTypeId,
    pub attributes: Option<Vec<Attribute>>,
}

impl ABIFunction {
    pub fn is_payable(&self) -> bool {
        self.attributes
            .iter()
            .flatten()
            .any(|attr| attr.name == "payable")
    }
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TypeMetadataDeclaration {
    #[serde(rename = "type")]
    pub type_field: String,
    pub metadata_type_id: MetadataTypeId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<TypeApplication>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_parameters: Option<Vec<MetadataTypeId>>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TypeConcreteDeclaration {
    #[serde(rename = "type")]
    pub type_field: String,
    pub concrete_type_id: ConcreteTypeId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata_type_id: Option<MetadataTypeId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_arguments: Option<Vec<ConcreteTypeId>>,
    #[serde(rename = "aliasOf", skip_serializing_if = "Option::is_none")]
    pub alias_of: Option<ConcreteTypeId>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TypeConcreteParameter {
    pub name: String,
    pub concrete_type_id: ConcreteTypeId,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TypeApplication {
    pub name: String,
    pub type_id: TypeId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    pub offset: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_arguments: Option<Vec<TypeApplication>>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LoggedType {
    pub log_id: String,
    pub concrete_type_id: ConcreteTypeId,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MessageType {
    pub message_id: String,
    pub concrete_type_id: ConcreteTypeId,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Configurable {
    pub name: String,
    pub concrete_type_id: ConcreteTypeId,
    pub offset: u64,
    #[serde(default)]
    pub indirect: bool,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Attribute {
    pub name: String,
    pub arguments: Vec<String>,
}

/// Represents a position in the source code where an error occurred.
/// An error can be a direct call to panic, or a call site of a function
/// that could panic.
#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ErrorPosition {
    #[serde(default)]
    /// The full-name of the enclosing function in which the error occurs.
    pub function: String,
    pub pkg: String,
    pub file: String,
    pub line: u64,
    pub column: u64,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ErrorDetails {
    pub pos: ErrorPosition,
    pub log_id: Option<String>,
    pub msg: Option<String>,
}

/// Represents a call that could panic during execution.
/// E.g., for the following code:
///
/// ```ignore
/// fn some_function() {
///    let _ = this_function_might_panic(42);
///}
/// ```
///
/// the ABI will contain a [PanickingCall] entry similar to:
///
/// ```ignore
///  "pos": {
///     "function": "some_package::some_module::some_function",
///     "pkg": "some_package@0.1.0",
///     "file": "src/some_module.sw",
///     "line": 4,
///     "column": 8
///   },
///   "function": "some_other_package::module::this_function_might_panic"
/// ```
#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PanickingCall {
    pub pos: ErrorPosition,
    /// The full-name of the function whose call caused the panic.
    pub function: String,
}

#[test]
fn version_extraction_test() {
    let v = Version("1.2".to_string());
    assert_eq!(v.major(), Some("1"));
    assert_eq!(v.minor(), Some("2"));

    let v = Version("1".to_string());
    assert_eq!(v.major(), Some("1"));
    assert_eq!(v.minor(), None);

    let v = Version("".to_string());
    assert_eq!(v.major(), None);
    assert_eq!(v.minor(), None);
}

// To see the JSON serialization printed, run the following command:
//   cargo test serde_json_serialization_tryout -- --include-ignored --nocapture
#[test]
#[ignore = "not a test, just a convenient way to try the serialization out"]
fn serde_json_serialization_tryout() {
    let mut abi = ProgramABI::default();

    abi.concrete_types.push(TypeConcreteDeclaration {
        type_field: "()".into(),
        concrete_type_id: ConcreteTypeId(
            "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d".into(),
        ),
        metadata_type_id: None,
        type_arguments: None,
        alias_of: None,
    });

    abi.concrete_types.push(TypeConcreteDeclaration {
        type_field: "enum MyError".into(),
        concrete_type_id: ConcreteTypeId(
            "44781f4b1eb667f225275b0a1c877dd4b9a8ab01f3cd01f8ed84f95c6cd2f363".into(),
        ),
        metadata_type_id: Some(MetadataTypeId(0)),
        type_arguments: None,
        alias_of: None,
    });

    abi.metadata_types.push(TypeMetadataDeclaration {
        type_field: "enum MyError".into(),
        metadata_type_id: MetadataTypeId(0),
        components: Some(vec![TypeApplication {
            offset: None,
            name: "MyErrorVariant".into(),
            type_id: TypeId::Concrete(ConcreteTypeId(
                "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d".into(),
            )),
            error_message: Some("My error variant error message.".into()),
            type_arguments: None,
        }]),
        type_parameters: None,
    });

    let mut error_codes = BTreeMap::new();

    error_codes.insert(
        0,
        ErrorDetails {
            pos: ErrorPosition {
                function: "my_function".to_string(),
                pkg: "my_lib".to_string(),
                file: "lib.rs".to_string(),
                line: 42,
                column: 13,
            },
            log_id: None,
            msg: Some("Error message.".to_string()),
        },
    );
    error_codes.insert(
        1,
        ErrorDetails {
            pos: ErrorPosition {
                function: "another_function".to_string(),
                pkg: "my_contract".to_string(),
                file: "main.rs".to_string(),
                line: 21,
                column: 34,
            },
            log_id: Some("4933727799282657266".to_string()),
            msg: None,
        },
    );

    abi.error_codes = Some(error_codes);

    let mut panicking_calls = BTreeMap::new();

    panicking_calls.insert(
        1,
        PanickingCall {
            pos: ErrorPosition {
                function: "my_function".to_string(),
                pkg: "my_lib".to_string(),
                file: "lib.rs".to_string(),
                line: 38,
                column: 13,
            },
            function: "this_function_might_panic".to_string(),
        },
    );

    abi.panicking_calls = Some(panicking_calls);

    println!("{}", serde_json::to_string_pretty(&abi).unwrap());
}
